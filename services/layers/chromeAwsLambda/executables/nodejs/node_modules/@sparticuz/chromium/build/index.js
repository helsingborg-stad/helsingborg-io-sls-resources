"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const node_fs_1 = require("node:fs");
const lambdafs_1 = __importDefault(require("./lambdafs"));
const node_path_1 = require("node:path");
const node_url_1 = require("node:url");
const helper_1 = require("./helper");
if (process.env.AWS_EXECUTION_ENV !== undefined && /^AWS_Lambda_nodejs(?:14|16|18)[.]x$/.test(process.env.AWS_EXECUTION_ENV) === true) {
    if (process.env.FONTCONFIG_PATH === undefined) {
        process.env.FONTCONFIG_PATH = '/tmp/aws';
    }
    if (process.env.LD_LIBRARY_PATH === undefined) {
        process.env.LD_LIBRARY_PATH = '/tmp/aws/lib';
    }
    else if (process.env.LD_LIBRARY_PATH.startsWith('/tmp/aws/lib') !== true) {
        process.env.LD_LIBRARY_PATH = [...new Set(['/tmp/aws/lib', ...process.env.LD_LIBRARY_PATH.split(':')])].join(':');
    }
}
class Chromium {
    /**
     * Downloads or symlinks a custom font and returns its basename, patching the environment so that Chromium can find it.
     * If headless is not true, `null` is returned instead.
     */
    static font(input) {
        if (Chromium.headless !== true) {
            return new Promise((resolve) => {
                return resolve(null);
            });
        }
        if (process.env.HOME === undefined) {
            process.env.HOME = '/tmp';
        }
        if ((0, node_fs_1.existsSync)(`${process.env.HOME}/.fonts`) !== true) {
            (0, node_fs_1.mkdirSync)(`${process.env.HOME}/.fonts`);
        }
        return new Promise((resolve, reject) => {
            if (/^https?:[/][/]/i.test(input) !== true) {
                input = `file://${input}`;
            }
            const url = new node_url_1.URL(input);
            const output = `${process.env.HOME}/.fonts/${url.pathname.split('/').pop()}`;
            if ((0, node_fs_1.existsSync)(output) === true) {
                return resolve(output.split('/').pop());
            }
            if (url.protocol === 'file:') {
                (0, node_fs_1.access)(url.pathname, (error) => {
                    if (error != null) {
                        return reject(error);
                    }
                    (0, node_fs_1.symlink)(url.pathname, output, (error) => {
                        return error != null ? reject(error) : resolve(url.pathname.split('/').pop());
                    });
                });
            }
            else {
                let handler = url.protocol === 'http:' ? require('http').get : require('https').get;
                handler(input, (response) => {
                    if (response.statusCode !== 200) {
                        return reject(`Unexpected status code: ${response.statusCode}.`);
                    }
                    const stream = (0, node_fs_1.createWriteStream)(output);
                    stream.once('error', (error) => {
                        return reject(error);
                    });
                    response.on('data', (chunk) => {
                        stream.write(chunk);
                    });
                    response.once('end', () => {
                        stream.end(() => {
                            return resolve(url.pathname.split('/').pop());
                        });
                    });
                });
            }
        });
    }
    /**
     * Returns a list of additional Chromium flags recommended for serverless environments.
     * The canonical list of flags can be found on https://peter.sh/experiments/chromium-command-line-switches/.
     */
    static get args() {
        const result = [
            '--allow-running-insecure-content',
            '--autoplay-policy=user-gesture-required',
            '--disable-background-timer-throttling',
            '--disable-component-update',
            '--disable-domain-reliability',
            '--disable-features=AudioServiceOutOfProcess,IsolateOrigins,site-per-process',
            '--disable-ipc-flooding-protection',
            '--disable-print-preview',
            '--disable-dev-shm-usage',
            '--disable-setuid-sandbox',
            '--disable-site-isolation-trials',
            '--disable-speech-api',
            '--disable-web-security',
            '--disk-cache-size=33554432',
            '--enable-features=SharedArrayBuffer',
            '--hide-scrollbars',
            '--ignore-gpu-blocklist',
            '--in-process-gpu',
            '--mute-audio',
            '--no-default-browser-check',
            '--no-first-run',
            '--no-pings',
            '--no-sandbox',
            '--no-zygote',
            '--use-gl=angle',
            '--use-angle=swiftshader',
            '--window-size=1920,1080', // https://source.chromium.org/search?q=lang:cpp+symbol:kWindowSize&ss=chromium
        ];
        if (Chromium.headless === true) {
            result.push('--single-process'); // https://source.chromium.org/search?q=lang:cpp+symbol:kSingleProcess&ss=chromium
        }
        else {
            result.push('--start-maximized'); // https://source.chromium.org/search?q=lang:cpp+symbol:kStartMaximized&ss=chromium
        }
        return result;
    }
    /**
     * Returns sensible default viewport settings.
     */
    static get defaultViewport() {
        return {
            deviceScaleFactor: 1,
            hasTouch: false,
            height: 1080,
            isLandscape: true,
            isMobile: false,
            width: 1920,
        };
    }
    /**
     * Inflates the included version of Chromium
     * @param input The location of the `bin` folder
     * @returns The path to the `chromium` binary
     */
    static async executablePath(input) {
        /**
         * If the `chromium` binary already exists in /tmp/chromium, return it.
         */
        if ((0, node_fs_1.existsSync)('/tmp/chromium') === true) {
            return Promise.resolve('/tmp/chromium');
        }
        if (input && (0, helper_1.isValidUrl)(input)) {
            return this.executablePath(await (0, helper_1.downloadAndExtract)(input));
        }
        /**
         * If input is defined, use that as the location of the brotli files,
         * otherwise, the default location is ../bin.
         * A custom location is needed for workflows that using custom packaging.
         */
        input ?? (input = (0, node_path_1.join)(__dirname, '..', 'bin'));
        /**
         * If the input directory doesn't exist, throw an error.
         */
        if (!(0, node_fs_1.existsSync)(input)) {
            throw new Error(`The input directory "${input}" does not exist.`);
        }
        const promises = [
            lambdafs_1.default.inflate(`${input}/chromium.br`),
            lambdafs_1.default.inflate(`${input}/swiftshader.tar.br`),
        ];
        if (process.env.AWS_EXECUTION_ENV !== undefined && /^AWS_Lambda_nodejs(?:14|16|18)[.]x$/.test(process.env.AWS_EXECUTION_ENV) === true) {
            promises.push(lambdafs_1.default.inflate(`${input}/aws.tar.br`));
        }
        const result = await Promise.all(promises);
        return result.shift();
    }
    /**
     * Returns a boolean indicating if we are running on AWS Lambda or Google Cloud Functions.
     * True is returned if the NODE_ENV is set to 'test' for easier integration testing.
     * False is returned if Serverless environment variables `IS_LOCAL` or `IS_OFFLINE` are set.
     */
    static get headless() {
        if (process.env.IS_LOCAL !== undefined || process.env.IS_OFFLINE !== undefined) {
            return false;
        }
        if (process.env.NODE_ENV === "test") {
            return true;
        }
        const environments = [
            'AWS_LAMBDA_FUNCTION_NAME',
            'FUNCTION_NAME',
            'FUNCTION_TARGET',
            'FUNCTIONS_EMULATOR',
        ];
        return environments.some((key) => process.env[key] !== undefined);
    }
}
module.exports = Chromium;
